%Préambule
\documentclass[12pt]{report}

\usepackage[french]{babel}
\usepackage{luatextra}
\usepackage{hyperref}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{listings}
\usepackage{caption}
\usepackage{amsmath}

\usepackage{lastpage}

\usepackage{fancyhdr}


\pagestyle{fancy}

\renewcommand{\thesection}{\Roman{section}}

%Information sur le document
\title{Projet Algorithme \\ \textit{Ascenseur} }
\date{16 juin 2019}
\author{Victor \textsc{ALAIN} \& Arthur \textsc{BLAISE} \& Amélie \textsc{GUEDES} \\ \& Loann \textsc{POTTIER}}

 \makeatletter
\let\theauthor\@author
\let\thetitle\@title
\let\thedate\@date
\makeatother

%En-tête
\fancyhead[C]{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\rightmark}

%Pied-de-Page
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}
\fancyfoot[R]{\thetitle}
\fancyfoot[L]{\thedate}

\begin{document}

\maketitle
\tableofcontents

\clearpage


\section{Introduction}

\subsection{Démarrage et explication}
	Tout d'abord nous avons décidé de jouer concrètement au jeu, afin d'essayer de comprendre les règles pour mis cerner les problèmes que l'on peut rencontrer en créant les algorithmes. Notre principal problème de compréhension dans le jeu était comment fonctionnent les atouts quels sont-ils et quelles cartes jouer et à quel moment. Ainsi, nous avons fait une partie et nous sommes parvenus à comprendre les principales règles de l'Ascenseur sans comprendre totalement comment fonctionnait le décompte des points. Cela nous a également permis de nous imaginer une schématisation de ce qu'on nous demandait de faire dans une grande globalité. Puis on a pris conscience des consignes qui était les suivantes:
	
\subsection{Problèmes à résoudre}
	
	Le but de ce projet est de réaliser un algorithme permettant d'exécuter le jeu l'Ascenseur. Pur ce faire, plusieurs consignes nous ont été donné(?): 
	\begin{itemize}
		\item  {Tout d'abord, nous devont réaliser un algorithme nommé "100\% humain" où il faut 
		initialiser certains paramètre notamment le nombre de joueurs (et donc le nombre de cartes maximal et par manche) puis l'utilisation des atouts et enfin les modalités de victoires et de défaites, en fixant le nombre de points gagnés par défaut, par plis remportés et les points perdus dans les deux mêmes catégories. Ensuite, il faut réaliser l'algorithme qui permet de jouer au jeu de l'ascenseur avec les deux phases : ascendente et descendante. Pour ce faire, il faut indiquer le nombre de manche par phase (Qui varie en fonction du nombre de joueur) et du nombre de tours par manches. Il faut également prendre en considération le fait que chaque cartes jouées est remis en bas du packet de cartes initiales c'est à dire qu'une carte sera jouées plusieurs fois dans la même partie. De plus, il faut que la distribution suivent un nombre logique (Dans le sens des aiguilles d'une montre notamment). En distribuant on finit toujours de distribuer par le joueur situé juste avant le joueur qui a reçu la 1ère carte. On doit également compter le nombre de points réaliser par chaque jour et donc, il faut, après chaque distribution avant de commencer la manche, que le joueur dise à haute voix le parie qu'il soit réalisé. \\ De surcroît, chaque jour ayant remporté le tour précédement, commence au tour suivant. Il est important également que chaque joueur jouent une carte de la couleur demandée si il en possède une, sinon il doit jouer un atout. Cependant, un joueur n'est pas obligé un atout si il n'a pas de carte de la même couleur, il peut déposer une carte quelconque mais il perdra le tour.
A la fin de la partie, le joueur possédant le plus de point à l'aide des contracts/paris gagnent la partie.  Attention, les jokers ne font pas partie du jeu.}
		\item {Dans un second temps, on va créer un algorithme nommé "Version'Ordinateur'" qui reprendra l'algorithme précédent mais qui va implémenter des joueurs artificiels, qui devront chercher à gagner à tout prix (Il s'agit donc d'une IA qui aura les mêmes pensées qu'un humain). On devra considérer une IA comme un humain, c'est-à-dire qu'il jouera exactement la même chose que ce que l'homme jouerai. } \\
		\\
	\end{itemize}
	
	\begin{figure}
	%\includegraphics[scale=0.30]{jeu-de-cartes-magicien-bicycle-stripper.jpg}
	 \caption{Jeu de carte utilisé lors d'une partie d'ascenseur}
	\end{figure}
		

		
\clearpage

		
\section{Explication des algorithmes}
Pour commencer voici comment est construit le code . tout part d'un programme principal\textit{start.pas} c'est ce programme qui lance toutes les fonctions secondaire et  les appellenjt dans le bon ordre et  qui permettent le bon déroulement du jeux. De surcroit ce programme appel des unités il faudra donc le compilé que tout fonctionne correctement    
 \subsection{Programmeur}
  
   \subsubsection{programme principal: start.pas}
   Le programme principal \textit{start.pas} ne demande au joueur que de se crée "un joueur " pour la machine et ainsi savoir combien d'utiisateur joueront. Dans ce programme il y a aura également la présence de \textbf{uses} dont seuls des fonctions nécessaire sont utilisées. Ce programme appelant des \textit{unit} ce dernier n'est pas excisement long ( c'est le but des units et de voir plus clair dans son code et également de savoir  d'où vient le probléme en cas d'erreur plus facilement 
   
   Ensuite durant le déroulement du programme les choses se complexifie  car le deroulement  du jeu est définie dans 2 unité l'une demande si le joueur soir afficher les régles \textit{intro.pas}  puis dans une autre chaque étapes du jeu  \textit{deroulement.pas}. 
 Afin d'assurer le déroulement visuelle du jeu l'aspect graphique est contenu d'un seul unit \textit{graph.pas}.
   
   \subsection{unités}
    auparavant nous avons parlé d'unité nous allons donc a présent détaillé celle-ci
   	\subsubsection{intro.pas}
   	Ce unit est particulièrement simple car il ne demande a l'utilisateur que si il souhaite lire les régles du jeu tout simplement 
 	\subsubsection{déroulement.pas}
  Ce unit est initalement le coeur du programme il fait donc appel à 11 fonctions et 9 procédure . Ces dernières sont :
  
  \begin{itemize}
  \item \textbf{Function Initjoueur}: qui demande le nombre de joueurs présent dans la partie 
  \item \textbf{Function inarray}: vérifie la présence d'une carte dans la liste
  \item \textbf{Function init}: Crée le paquet de carte 
  \item \textbf{Function initplimanche}: permet de ramener le nombre de plis des joueurs a zéro avant la nouvelle manche
  \item \textbf{Function InitAtout}:
  \item \textbf{Function NombreManche}: Calcul le nombre de manches nécessaires vis-à-vis du nombre de joueur
  \item \textbf{Function VerifcouleurExiste}: Verifie la couleur de cartes séléctionner par le joueur
  \item \textbf{Function Randomdeck}: Mélange les cartes avec un 		   \textit{random}
  \item \textbf{Function VerifvaleurExiste} : Verifie la valeur de la carte choisi
  \item \textbf{Function VerifieCareAjoueur} : Verifie que le joueur possède la carte qu'il a selectionné 
  \item \textbf{Function ChoixCarte}: appliques les verifications sur le choix des cartes 
  \item \textbf{Function VerifDroitDePoser}: Vérifie si la cartes peut-être poser sans enfreindre les régles 
  \item \textbf{Function pli}: a la fin d'un tour renvoi un entier pour désigner le gagnant 
  \item \textbf{RecherchePseudoGagnant}: retrouve le nom du gagnant et lui associe un victoire et l'enregistre 
  \item \textbf{Procedure RetirePaquet}: Retire la carte du paquet une fois sélectionner 
  \item \textbf{Procedure OrdreJoueur}: Permet de determiné et d'appliquer l'ordre de jeu des joueurs pour le prochain pli
  \item \textbf{Procedure Manche}: Applique les etats d'une manche a savoir le nombre de cartes au joueurs et l'enregistrement des paris 
  \item \textbf{Procedure Ascendant}: donne une carte de plus a chaque joueur
  \item \textbf{Procedure Descandant}: retire une carte a chaque joueur 
  \item \textbf{Procedure ComptageDePoint}: Compte le nombre de point associé aux joueurs 
  \item \textbf{Procedure distribuer}: Distribue les cartes aux joueurs et empêche le doublon de carte 
  \item \textbf{Procedure Parions}: Demandes aux joueurs d'entrer la valeurs de leurs mise et les enregistres dans la variable joueurs en debut de manche 
  \item \textbf{Procedure plusjeune}: change la liste des joueurs pour trié les joueurs par ages du plus jeune au plus vieux et designé le premier joueur a jouer pour la 1er manche 
  \item 
  \end{itemize}
  
  \subsubsection{unit graphique}
	
	brah  
  
  \begin{itemize}
  \item \textbf{Function init}: initialiser la fenêtre, et créer la référence de l'image de fond (/! à appeler en premier)
  \item \textbf{Procédure set\_deck} : initialise la liste des cartes présente dans le deck
  \item \textbf{procedure set\_cartes\_main}: defini les cartes dans les mains du joueur
  \item \textbf{procedure set\_joueur}: defini à qui c'est de jouer dans le petit rectangle en haut a gauche 
  \item \textbf{procedure set\_fps} : initialise le nombre d'images par seconde 
\item \textbf{procedure convert\_carte}(var cart:carte) : Convertir une carte basique en une carte compatible avec la lib graphique
\item \textbf{function load\_players}(players\_list:joueursArray): Convertir la liste des joueurs de base en une liste utilisable par la lib graphique
\item \textbf{function convert\_text}(message:string): Convertir un texte
\item \textbf{function convert\_couleur} : Permet de convertir le type custom en bit aifn que pascal comprenne la couleur

\item \textbf{procedure afficher\_cartes}: afficher une liste de cartes, avec possibilité de réduire/augmenter la taille
\item \textbf{procedure afficher\_joueurs}: Afficher la liste des joueurs autours de la "table"
\item \textbf{procedure afficher\_background}: Affiche l'image de fond
\item \textbf{procedure afficher\_texte}: Affiche un message
\item \textbf{procedure refresh}: Afficher l'image
\item \textbf{procedure focus\_joueur}: Affiche le pseudo d'un joueur en haut à gauche de l'écran
\item \textbf{procedure afficher\_atout}(cart:carte): Affiche la couleur de l'atout actuel
\item \textbf{procedure afficher\_manche} : Affiche la liste des cartes jouées
\item \textbf{procedure afficher\_cadre}: affiche le cadre autour de la carte survolées par la souris 
\item \textbf{function on\_click}: Retourne la carte où le joueur a cliqué
\item  \textbf{function saisir\_txt ]} :  demande à l'utilisateur de saisir du texte
\item \textbf{function sdl\_update } : Retourne 1 lorsque quelque chose bouge sur l'écran (clic etc)
\item \textbf{function sdl\_do\_quit} : Si l'utilisateur ferme la fenêtre
\item \textbf{function sdl\_get\_mouse\_xy} : Coordonnées x - y de la souris
\item \textbf{function sdl\_get\_keypressed} : Si une touche du clavier est pressée, retourne sa valeur
	\end{itemize}

\section{Diffultés }
	\subsection{Coeur du programme}
	
	\subsection{unité grahique}
(probleme packet... etc a toi de voir artur )

\section{Nos choix pour l'implentation}
	\subsection{coeur de programme}
Durant le codage de ce programme nous avons fais le choix de découper notre programme en unités, composées et d'un multitude de fonction. Cela nous permet d'avoir un code plus lisible, plus facile à modifier, et plus facile à corriger.
	\subsection{unit}
redimensions de la fenêtre ,
\section{avantages et limites}


\section{contribution des éléves}
\subsection{Arthur Blaise}
	Arthur s'est oocupé de l'unité graphique durant le projet 
\subsection{Amelie Guedes et Victor Alain}
 Amelie et Victor ce sont occupé du coeur du programme 
\subsection{Loann Pottier}
Loann s'est occupé du rapport 
\section{Bilan personnel}
\subsection{Amélie Guedes}
\subsection{Arthur Blaise}
\subsection{Victor ALain}
\subsection{Pottier Loann}
\section{Conclusion}
			
\end{document}
